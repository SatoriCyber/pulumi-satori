// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface AccessRuleIdentity {
    /**
     * Directory group ID for identity of type GROUP.
     * Can not be changed after creation.
     */
    groupId?: string;
    /**
     * User/group name for identity types of USER and IDP_GROUP.
     * Can not be changed after creation.
     */
    name?: string;
    /**
     * Identity type, valid types are: USER, DB*USER, IDP*GROUP, GROUP, DATABRICKS*GROUP, DATABRICKS*SERVICE*PRINCIPAL, SNOWFLAKE*ROLE, EVERYONE.
     * Can not be changed after creation.
     */
    type: string;
}

export interface CustomTaxonomyClassifierCustomConfig {
    /**
     * Field name pattern.
     */
    fieldNamePattern?: string;
    /**
     * Field type, valid types are: ANY, TEXT, NUMERIC, DATE.
     */
    fieldType: string;
    /**
     * Should value match be case sensitive. Defaults to `true`.
     */
    valueCaseSensitive?: boolean;
    /**
     * Value pattern.
     */
    valuePattern?: string;
    /**
     * List of possible field values.
     */
    values?: string[];
}

export interface CustomTaxonomyClassifierSatoriBasedConfig {
    /**
     * Base Satori classifier ID.
     * See https://satoricyber.com/docs/taxonomy/standard-classifiers for a list of possible values.
     */
    satoriBaseClassifier: string;
}

export interface CustomTaxonomyClassifierScope {
    /**
     * IDs of datasets to include in the scope.
     */
    datasets?: string[];
    /**
     * Location to include in the scope.
     */
    includeLocations?: outputs.CustomTaxonomyClassifierScopeIncludeLocation[];
}

export interface CustomTaxonomyClassifierScopeIncludeLocation {
    /**
     * Data store ID.
     */
    datastore: string;
    /**
     * Location for a data store. Can include only one location type field from the above: relational*location, mysql*location, athena*location, mongo*location and s3*location . Conflicts with 'relational*location' field.
     */
    location?: outputs.CustomTaxonomyClassifierScopeIncludeLocationLocation;
    /**
     * Location for a relational data store.
     *
     * @deprecated The 'relational_location' field has been deprecated. Please use the 'location' field instead.
     */
    relationalLocation?: outputs.CustomTaxonomyClassifierScopeIncludeLocationRelationalLocation;
}

export interface CustomTaxonomyClassifierScopeIncludeLocationLocation {
    /**
     * Location for Athena data store.
     */
    athenaLocation?: outputs.CustomTaxonomyClassifierScopeIncludeLocationLocationAthenaLocation;
    /**
     * Location for MongoDB data store.
     */
    mongoLocation?: outputs.CustomTaxonomyClassifierScopeIncludeLocationLocationMongoLocation;
    /**
     * Location for MySql and MariaDB data stores.
     */
    mysqlLocation?: outputs.CustomTaxonomyClassifierScopeIncludeLocationLocationMysqlLocation;
    /**
     * Location for a relational data store.
     */
    relationalLocation?: outputs.CustomTaxonomyClassifierScopeIncludeLocationLocationRelationalLocation;
    /**
     * Location for S3 data store.
     */
    s3Location?: outputs.CustomTaxonomyClassifierScopeIncludeLocationLocationS3Location;
}

export interface CustomTaxonomyClassifierScopeIncludeLocationLocationAthenaLocation {
    /**
     * Catalog name.
     */
    catalog: string;
    /**
     * Database name.
     */
    db?: string;
    /**
     * Table name.
     */
    table?: string;
}

export interface CustomTaxonomyClassifierScopeIncludeLocationLocationMongoLocation {
    /**
     * Collection name.
     */
    collection?: string;
    /**
     * Database name.
     */
    db: string;
}

export interface CustomTaxonomyClassifierScopeIncludeLocationLocationMysqlLocation {
    /**
     * Database name.
     */
    db: string;
    /**
     * Table name.
     */
    table?: string;
}

export interface CustomTaxonomyClassifierScopeIncludeLocationLocationRelationalLocation {
    /**
     * Database name.
     */
    db: string;
    /**
     * Schema name.
     */
    schema?: string;
    /**
     * Table name.
     */
    table?: string;
}

export interface CustomTaxonomyClassifierScopeIncludeLocationLocationS3Location {
    /**
     * Bucket name.
     */
    bucket: string;
    /**
     * Object Key name.
     */
    objectKey?: string;
}

export interface CustomTaxonomyClassifierScopeIncludeLocationRelationalLocation {
    /**
     * Database name.
     */
    db: string;
    /**
     * Schema name.
     */
    schema?: string;
    /**
     * Table name.
     */
    table?: string;
}

export interface DatasetAccessControlSettings {
    /**
     * Enforce access control to this dataset. Defaults to `false`.
     */
    enableAccessControl?: boolean;
}

export interface DatasetCustomPolicy {
    /**
     * Dataset custom policy priority. Defaults to `100`.
     */
    priority?: number;
    /**
     * Custom policy rules YAML.
     */
    rulesYaml?: string;
    /**
     * Custom policy tags YAML.
     */
    tagsYaml?: string;
}

export interface DatasetDefinition {
    /**
     * Identities of Satori users/groups that will be set as dataset approvers.
     */
    approvers?: outputs.DatasetDefinitionApprover[];
    /**
     * Dataset description.
     */
    description?: string;
    /**
     * Location to exclude from dataset.
     */
    excludeLocations?: outputs.DatasetDefinitionExcludeLocation[];
    /**
     * Location to include in dataset.
     */
    includeLocations?: outputs.DatasetDefinitionIncludeLocation[];
    /**
     * Dataset name.
     */
    name: string;
    /**
     * IDs of Satori users that will be set as dataset owners.
     */
    owners?: string[];
}

export interface DatasetDefinitionApprover {
    /**
     * The ID of the approver entity
     */
    id: string;
    /**
     * Approver type, can be either `GROUP` (IdP Group alone) or `USER`
     */
    type: string;
}

export interface DatasetDefinitionExcludeLocation {
    /**
     * Data store ID.
     */
    datastore: string;
    /**
     * Location for a data store. Can include only one location type field from the above: relational*location, mysql*location, athena*location, mongo*location and s3*location . Conflicts with 'relational*location' field.
     */
    location?: outputs.DatasetDefinitionExcludeLocationLocation;
    /**
     * Location for a relational data store.
     *
     * @deprecated The 'relational_location' field has been deprecated. Please use the 'location' field instead.
     */
    relationalLocation?: outputs.DatasetDefinitionExcludeLocationRelationalLocation;
}

export interface DatasetDefinitionExcludeLocationLocation {
    /**
     * Location for Athena data store.
     */
    athenaLocation?: outputs.DatasetDefinitionExcludeLocationLocationAthenaLocation;
    /**
     * Location for MongoDB data store.
     */
    mongoLocation?: outputs.DatasetDefinitionExcludeLocationLocationMongoLocation;
    /**
     * Location for MySql and MariaDB data stores.
     */
    mysqlLocation?: outputs.DatasetDefinitionExcludeLocationLocationMysqlLocation;
    /**
     * Location for a relational data store.
     */
    relationalLocation?: outputs.DatasetDefinitionExcludeLocationLocationRelationalLocation;
    /**
     * Location for S3 data store.
     */
    s3Location?: outputs.DatasetDefinitionExcludeLocationLocationS3Location;
}

export interface DatasetDefinitionExcludeLocationLocationAthenaLocation {
    /**
     * Catalog name.
     */
    catalog: string;
    /**
     * Database name.
     */
    db?: string;
    /**
     * Table name.
     */
    table?: string;
}

export interface DatasetDefinitionExcludeLocationLocationMongoLocation {
    /**
     * Collection name.
     */
    collection?: string;
    /**
     * Database name.
     */
    db: string;
}

export interface DatasetDefinitionExcludeLocationLocationMysqlLocation {
    /**
     * Database name.
     */
    db: string;
    /**
     * Table name.
     */
    table?: string;
}

export interface DatasetDefinitionExcludeLocationLocationRelationalLocation {
    /**
     * Database name.
     */
    db: string;
    /**
     * Schema name.
     */
    schema?: string;
    /**
     * Table name.
     */
    table?: string;
}

export interface DatasetDefinitionExcludeLocationLocationS3Location {
    /**
     * Bucket name.
     */
    bucket: string;
    /**
     * Object Key name.
     */
    objectKey?: string;
}

export interface DatasetDefinitionExcludeLocationRelationalLocation {
    /**
     * Database name.
     */
    db: string;
    /**
     * Schema name.
     */
    schema?: string;
    /**
     * Table name.
     */
    table?: string;
}

export interface DatasetDefinitionIncludeLocation {
    /**
     * Data store ID.
     */
    datastore: string;
    /**
     * Location for a data store. Can include only one location type field from the above: relational*location, mysql*location, athena*location, mongo*location and s3*location . Conflicts with 'relational*location' field.
     */
    location?: outputs.DatasetDefinitionIncludeLocationLocation;
    /**
     * Location for a relational data store.
     *
     * @deprecated The 'relational_location' field has been deprecated. Please use the 'location' field instead.
     */
    relationalLocation?: outputs.DatasetDefinitionIncludeLocationRelationalLocation;
}

export interface DatasetDefinitionIncludeLocationLocation {
    /**
     * Location for Athena data store.
     */
    athenaLocation?: outputs.DatasetDefinitionIncludeLocationLocationAthenaLocation;
    /**
     * Location for MongoDB data store.
     */
    mongoLocation?: outputs.DatasetDefinitionIncludeLocationLocationMongoLocation;
    /**
     * Location for MySql and MariaDB data stores.
     */
    mysqlLocation?: outputs.DatasetDefinitionIncludeLocationLocationMysqlLocation;
    /**
     * Location for a relational data store.
     */
    relationalLocation?: outputs.DatasetDefinitionIncludeLocationLocationRelationalLocation;
    /**
     * Location for S3 data store.
     */
    s3Location?: outputs.DatasetDefinitionIncludeLocationLocationS3Location;
}

export interface DatasetDefinitionIncludeLocationLocationAthenaLocation {
    /**
     * Catalog name.
     */
    catalog: string;
    /**
     * Database name.
     */
    db?: string;
    /**
     * Table name.
     */
    table?: string;
}

export interface DatasetDefinitionIncludeLocationLocationMongoLocation {
    /**
     * Collection name.
     */
    collection?: string;
    /**
     * Database name.
     */
    db: string;
}

export interface DatasetDefinitionIncludeLocationLocationMysqlLocation {
    /**
     * Database name.
     */
    db: string;
    /**
     * Table name.
     */
    table?: string;
}

export interface DatasetDefinitionIncludeLocationLocationRelationalLocation {
    /**
     * Database name.
     */
    db: string;
    /**
     * Schema name.
     */
    schema?: string;
    /**
     * Table name.
     */
    table?: string;
}

export interface DatasetDefinitionIncludeLocationLocationS3Location {
    /**
     * Bucket name.
     */
    bucket: string;
    /**
     * Object Key name.
     */
    objectKey?: string;
}

export interface DatasetDefinitionIncludeLocationRelationalLocation {
    /**
     * Database name.
     */
    db: string;
    /**
     * Schema name.
     */
    schema?: string;
    /**
     * Table name.
     */
    table?: string;
}

export interface DatastoreBaselineSecurityPolicy {
    /**
     * Exempt users and patterns from baseline security policy
     */
    exclusions: outputs.DatastoreBaselineSecurityPolicyExclusions;
    /**
     * DataStore security policy. Defaults to `BASELINE_POLICY`.
     */
    type?: string;
    /**
     * UnassociatedQueriesCategory
     */
    unassociatedQueriesCategory: outputs.DatastoreBaselineSecurityPolicyUnassociatedQueriesCategory;
    /**
     * UnsupportedQueriesCategory
     */
    unsupportedQueriesCategory: outputs.DatastoreBaselineSecurityPolicyUnsupportedQueriesCategory;
}

export interface DatastoreBaselineSecurityPolicyExclusions {
    /**
     * Exempt Users from the Baseline Security Policy
     */
    excludedIdentities?: outputs.DatastoreBaselineSecurityPolicyExclusionsExcludedIdentity[];
    /**
     * Exempt Queries from the Baseline Security Policy
     */
    excludedQueryPatterns?: outputs.DatastoreBaselineSecurityPolicyExclusionsExcludedQueryPattern[];
}

export interface DatastoreBaselineSecurityPolicyExclusionsExcludedIdentity {
    /**
     * Username
     */
    identity?: string;
    /**
     * USER type is supported
     */
    identityType?: string;
}

export interface DatastoreBaselineSecurityPolicyExclusionsExcludedQueryPattern {
    /**
     * Query pattern
     */
    pattern?: string;
}

export interface DatastoreBaselineSecurityPolicyUnassociatedQueriesCategory {
    /**
     * Default policy action for querying locations that are not associated with a dataset, modes supported:  PASS笏コEDACT笏ィLOCK.
     */
    queryAction?: string;
}

export interface DatastoreBaselineSecurityPolicyUnsupportedQueriesCategory {
    /**
     * Default policy action for querying locations that are not associated with a dataset, modes supported:  PASS笏コEDACT笏ィLOCK.
     */
    queryAction: string;
}

export interface DatastoreDatastoreSetting {
    /**
     * MongoDB deployment type, for now supports only mongodb+srv and mongodb deployment
     */
    deploymentType?: string;
}

export interface DatastoreNetworkPolicy {
    /**
     * Allowed Ip Rules
     */
    allowedRules?: outputs.DatastoreNetworkPolicyAllowedRule[];
    /**
     * Blocked Ips Rules
     */
    blockedRules?: outputs.DatastoreNetworkPolicyBlockedRule[];
}

export interface DatastoreNetworkPolicyAllowedRule {
    /**
     * Defines IP addresses or CIDR ranges allowed to access the datastore
     */
    ipRanges?: outputs.DatastoreNetworkPolicyAllowedRuleIpRange[];
    /**
     * custom description for allowed IP ranges
     */
    note?: string;
}

export interface DatastoreNetworkPolicyAllowedRuleIpRange {
    /**
     * Range (IP or CIDR)
     */
    ipRange: string;
}

export interface DatastoreNetworkPolicyBlockedRule {
    /**
     * Defines IP addresses or CIDR ranges allowed to access the datastore
     */
    ipRanges?: outputs.DatastoreNetworkPolicyBlockedRuleIpRange[];
    /**
     * custom description for allowed IP ranges
     */
    note?: string;
}

export interface DatastoreNetworkPolicyBlockedRuleIpRange {
    /**
     * Range (IP or CIDR)
     */
    ipRange: string;
}

export interface DatastoreSatoriAuthSettings {
    /**
     * Root user credentials
     */
    credentials?: outputs.DatastoreSatoriAuthSettingsCredentials;
    /**
     * Enables Satori Personal Access Token authentication for this data store. to be able using personal access token for authentication on this data store - data store temporary credentials must be enabled and personal access token feature should be enabled for the current account (see Account setting page in Satori platform). Defaults to `false`.
     */
    enablePersonalAccessToken?: boolean;
    /**
     * Enables Satori Data Store authentication. Defaults to `false`.
     */
    enabled?: boolean;
}

export interface DatastoreSatoriAuthSettingsCredentials {
    password: string;
    /**
     * Username of root user
     */
    username: string;
}

export interface DirectoryGroupMember {
    /**
     * Data store type for member of type DB_ROLE, valid types are: SNOWFLAKE, REDSHIFT, BIGQUERY, POSTGRESQL, ATHENA, MSSQL, SYNAPSE
     */
    dataStoreType?: string;
    /**
     * Member email available for types: USERNAME.
     */
    email?: string;
    /**
     * Directory group ID for member of type DIRECTORY_GROUP.
     */
    groupId?: string;
    /**
     * Identity provider type for member of type IDP_GROUP, valid identity providers are: OKTA, AZURE, ONELOGIN
     */
    identityProvider?: string;
    /**
     * Member name for types: USERNAME, IDP*GROUP and DB*ROLE.
     */
    name?: string;
    /**
     * Member type, valid types are: USERNAME, IDP*GROUP, DB*ROLE, DIRECTORY_GROUP.
     */
    type: string;
}

export interface MaskingProfileCondition {
    /**
     * Replacement, relevant for: REPLACE*CHAR, REPLACE*STRING.
     */
    replacement?: string;
    /**
     * Tag.
     */
    tag: string;
    /**
     * Truncate, relevant for: TRUNCATE.
     */
    truncate?: number;
    /**
     * Type. Can be one of [TRUNCATE, REPLACE*CHAR, REPLACE*STRING, HASH, EMAIL*PREFIX, EMAIL*SUFFIX, EMAIL*FULL, EMAIL*HASH, CREDIT*CARD*PREFIX, CREDIT*CARD*FULL, CREDIT*CARD*HASH, IP*SUFFIX, IP*FULL, IP*HASH, DATE*YEAR*ONLY, DATE*1970*AGAIN, NO*ACTION, REDACT, NUMBER*ZERO, NUMBER*ROUND, ...]
     */
    type: string;
}

export interface RequestAccessRuleApprover {
    /**
     * The ID of the approver entity, when type is `MANAGER` this field must not be set.
     */
    id?: string;
    /**
     * Approver type, can be either `GROUP` (IdP Group alone) or `USER`
     */
    type: string;
}

export interface RequestAccessRuleExpireIn {
    /**
     * Unit type for units field, possible values are: MINUTES, HOURS, DAYS, WEEKS, MONTHS, YEARS.
     */
    unitType: string;
    /**
     * Number of units of unit_type.
     */
    units: number;
}

export interface RequestAccessRuleIdentity {
    /**
     * Directory group ID for identity of type GROUP.
     * Can not be changed after creation.
     */
    groupId?: string;
    /**
     * User/group name for identity types of USER and IDP_GROUP.
     * Can not be changed after creation.
     */
    name?: string;
    /**
     * Identity type, valid types are: USER, DB*USER, IDP*GROUP, GROUP, DATABRICKS*GROUP, DATABRICKS*SERVICE*PRINCIPAL, SNOWFLAKE*ROLE, EVERYONE.
     * Can not be changed after creation.
     */
    type: string;
}

export interface SecurityPolicyProfile {
    /**
     * Masking profile.
     */
    masking?: outputs.SecurityPolicyProfileMasking;
    /**
     * Row level security profile
     */
    rowLevelSecurity?: outputs.SecurityPolicyProfileRowLevelSecurity;
}

export interface SecurityPolicyProfileMasking {
    /**
     * Is active.
     */
    active: boolean;
    /**
     * Masking Rule.
     */
    rules?: outputs.SecurityPolicyProfileMaskingRule[];
}

export interface SecurityPolicyProfileMaskingRule {
    /**
     * Rule action.
     */
    action: outputs.SecurityPolicyProfileMaskingRuleAction;
    /**
     * Is active.
     */
    active: boolean;
    /**
     * Masking criteria.
     */
    criteria: outputs.SecurityPolicyProfileMaskingRuleCriteria;
    /**
     * Rule description.
     */
    description: string;
    /**
     * Rule id, has to be unique.
     */
    id: string;
}

export interface SecurityPolicyProfileMaskingRuleAction {
    /**
     * The reference id to be applied as masking profile.
     */
    maskingProfileId: string;
    /**
     * Identity type, valid types are: USER, DB*USER, IDP*GROUP, GROUP, DATABRICKS*GROUP, DATABRICKS*SERVICE*PRINCIPAL, SNOWFLAKE*ROLE, CEL, EVERYONE.
     * Can not be changed after creation.
     */
    type?: string;
}

export interface SecurityPolicyProfileMaskingRuleCriteria {
    /**
     * Identity condition, for example IS_NOT, IS, etc.
     */
    condition: string;
    /**
     * Identity to apply the rule for.
     */
    identity: outputs.SecurityPolicyProfileMaskingRuleCriteriaIdentity;
}

export interface SecurityPolicyProfileMaskingRuleCriteriaIdentity {
    /**
     * Directory group ID for identity of type GROUP.
     * Can not be changed after creation.
     */
    groupId?: string;
    /**
     * User/group name for identity types of USER and IDP_GROUP or a custom expression based on attributes of the identity for CEL identity type.
     * Can not be changed after creation.
     */
    name?: string;
    /**
     * Identity type, valid types are: USER, DB*USER, IDP*GROUP, GROUP, DATABRICKS*GROUP, DATABRICKS*SERVICE*PRINCIPAL, SNOWFLAKE*ROLE, CEL, EVERYONE.
     * Can not be changed after creation.
     */
    type: string;
}

export interface SecurityPolicyProfileRowLevelSecurity {
    /**
     * Is active.
     */
    active: boolean;
    /**
     * Row Level Security Mapping.
     */
    mappings?: outputs.SecurityPolicyProfileRowLevelSecurityMapping[];
    /**
     * Masking Rule.
     */
    rules?: outputs.SecurityPolicyProfileRowLevelSecurityRule[];
}

export interface SecurityPolicyProfileRowLevelSecurityMapping {
    /**
     * A list of default values to be applied in this filter if there was no match. Values are dependent on their type and has to be homogeneous
     */
    defaults: outputs.SecurityPolicyProfileRowLevelSecurityMappingDefaults;
    /**
     * Filter definition.
     */
    filter: outputs.SecurityPolicyProfileRowLevelSecurityMappingFilter;
    /**
     * User/group name for identity types of USER and IDP_GROUP or a custom expression based on attributes of the identity for CEL identity type.
     * Can not be changed after creation.
     */
    name: string;
}

export interface SecurityPolicyProfileRowLevelSecurityMappingDefaults {
    /**
     * Identity type, valid types are: USER, DB*USER, IDP*GROUP, GROUP, DATABRICKS*GROUP, DATABRICKS*SERVICE*PRINCIPAL, SNOWFLAKE*ROLE, CEL, EVERYONE.
     * Can not be changed after creation.
     */
    type: string;
    /**
     * List of values, when NO*VALUE or ALL*OTHER_VALUES are defined, the list has to be empty
     */
    values: string[];
}

export interface SecurityPolicyProfileRowLevelSecurityMappingFilter {
    /**
     * Masking criteria.
     */
    criteria: outputs.SecurityPolicyProfileRowLevelSecurityMappingFilterCriteria;
    /**
     * A list of values to be applied in this filter. Values are dependent on their type and has to be homogeneous
     */
    values: outputs.SecurityPolicyProfileRowLevelSecurityMappingFilterValues;
}

export interface SecurityPolicyProfileRowLevelSecurityMappingFilterCriteria {
    /**
     * Identity condition, for example IS_NOT, IS, etc.
     */
    condition: string;
    /**
     * Identity to apply the rule for.
     */
    identity: outputs.SecurityPolicyProfileRowLevelSecurityMappingFilterCriteriaIdentity;
}

export interface SecurityPolicyProfileRowLevelSecurityMappingFilterCriteriaIdentity {
    /**
     * Directory group ID for identity of type GROUP.
     * Can not be changed after creation.
     */
    groupId?: string;
    /**
     * User/group name for identity types of USER and IDP_GROUP or a custom expression based on attributes of the identity for CEL identity type.
     * Can not be changed after creation.
     */
    name?: string;
    /**
     * Identity type, valid types are: USER, DB*USER, IDP*GROUP, GROUP, DATABRICKS*GROUP, DATABRICKS*SERVICE*PRINCIPAL, SNOWFLAKE*ROLE, CEL, EVERYONE.
     * Can not be changed after creation.
     */
    type: string;
}

export interface SecurityPolicyProfileRowLevelSecurityMappingFilterValues {
    /**
     * Identity type, valid types are: USER, DB*USER, IDP*GROUP, GROUP, DATABRICKS*GROUP, DATABRICKS*SERVICE*PRINCIPAL, SNOWFLAKE*ROLE, CEL, EVERYONE.
     * Can not be changed after creation.
     */
    type: string;
    /**
     * List of values, when NO*VALUE or ALL*OTHER_VALUES are defined, the list has to be empty
     */
    values: string[];
}

export interface SecurityPolicyProfileRowLevelSecurityRule {
    /**
     * Is active.
     */
    active: boolean;
    /**
     * Rule description.
     */
    description: string;
    /**
     * Filter definition.
     */
    filter: outputs.SecurityPolicyProfileRowLevelSecurityRuleFilter;
    /**
     * Rule id, has to be unique.
     */
    id: string;
}

export interface SecurityPolicyProfileRowLevelSecurityRuleFilter {
    /**
     * Describes if logic yaml contains complex configuration. Defaults to `true`.
     */
    advanced?: boolean;
    /**
     * Datastore ID.
     */
    datastoreId: string;
    /**
     * Location to to be included in the rule. The 'location*prefix' field has been deprecated. Please use the 'location' field instead.
     *
     * @deprecated The 'location_prefix' field has been deprecated. Please use the 'location' field instead.
     */
    locationPrefixes?: outputs.SecurityPolicyProfileRowLevelSecurityRuleFilterLocationPrefix[];
    /**
     * Location to be included in the rule.
     */
    locations?: outputs.SecurityPolicyProfileRowLevelSecurityRuleFilterLocation[];
    /**
     * Conditional rule, for more info see https://satoricyber.com/docs/security-policies/#setting-up-data-filtering.
     */
    logicYaml: string;
}

export interface SecurityPolicyProfileRowLevelSecurityRuleFilterLocation {
    /**
     * Location for Athena data store.
     */
    athenaLocation?: outputs.SecurityPolicyProfileRowLevelSecurityRuleFilterLocationAthenaLocation;
    /**
     * Location for MongoDB data store.
     */
    mongoLocation?: outputs.SecurityPolicyProfileRowLevelSecurityRuleFilterLocationMongoLocation;
    /**
     * Location for MySql and MariaDB data stores.
     */
    mysqlLocation?: outputs.SecurityPolicyProfileRowLevelSecurityRuleFilterLocationMysqlLocation;
    /**
     * Location for a relational data store.
     */
    relationalLocation?: outputs.SecurityPolicyProfileRowLevelSecurityRuleFilterLocationRelationalLocation;
    /**
     * Location for S3 data store.
     */
    s3Location?: outputs.SecurityPolicyProfileRowLevelSecurityRuleFilterLocationS3Location;
}

export interface SecurityPolicyProfileRowLevelSecurityRuleFilterLocationAthenaLocation {
    /**
     * Catalog name.
     */
    catalog: string;
    /**
     * Database name.
     */
    db?: string;
    /**
     * Table name.
     */
    table?: string;
}

export interface SecurityPolicyProfileRowLevelSecurityRuleFilterLocationMongoLocation {
    /**
     * Collection name.
     */
    collection?: string;
    /**
     * Database name.
     */
    db: string;
}

export interface SecurityPolicyProfileRowLevelSecurityRuleFilterLocationMysqlLocation {
    /**
     * Database name.
     */
    db: string;
    /**
     * Table name.
     */
    table?: string;
}

export interface SecurityPolicyProfileRowLevelSecurityRuleFilterLocationPrefix {
    /**
     * Database name.
     */
    db: string;
    /**
     * Schema name.
     */
    schema?: string;
    /**
     * Table name.
     */
    table?: string;
}

export interface SecurityPolicyProfileRowLevelSecurityRuleFilterLocationRelationalLocation {
    /**
     * Database name.
     */
    db: string;
    /**
     * Schema name.
     */
    schema?: string;
    /**
     * Table name.
     */
    table?: string;
}

export interface SecurityPolicyProfileRowLevelSecurityRuleFilterLocationS3Location {
    /**
     * Bucket name.
     */
    bucket: string;
    /**
     * Object Key name.
     */
    objectKey?: string;
}

export interface SelfServiceAccessRuleExpireIn {
    /**
     * Unit type for units field, possible values are: MINUTES, HOURS, DAYS, WEEKS, MONTHS, YEARS.
     */
    unitType: string;
    /**
     * Number of units of unit_type.
     */
    units: number;
}

export interface SelfServiceAccessRuleIdentity {
    /**
     * Directory group ID for identity of type GROUP.
     * Can not be changed after creation.
     */
    groupId?: string;
    /**
     * User/group name for identity types of USER and IDP_GROUP.
     * Can not be changed after creation.
     */
    name?: string;
    /**
     * Identity type, valid types are: USER, DB*USER, IDP*GROUP, GROUP, DATABRICKS*GROUP, DATABRICKS*SERVICE*PRINCIPAL, SNOWFLAKE*ROLE, EVERYONE.
     * Can not be changed after creation.
     */
    type: string;
}

